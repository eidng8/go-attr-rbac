package handlers

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"slices"
	"strconv"
	"strings"

	"github.com/eidng8/go-utils"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	jsoniter "github.com/json-iterator/go"

	"github.com/eidng8/go-attr-rbac/api"
	"github.com/eidng8/go-attr-rbac/ent"
	_ "github.com/eidng8/go-attr-rbac/ent/runtime"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

type Server struct {
	db *ent.Client
	// base URL for the URL generation
	baseUrl string
	// private key for JWT token generation
	secret []byte
	// number of rows to return in hint requests
	hintSize int
	// list of public operations
	publicOperations []string
}

func NewEngine(entClient *ent.Client) (*Server, *gin.Engine, error) {
	if nil != entClient {
		dbSetup(entClient)
		// entClient = entClient.Debug()
	}
	gin.SetMode(utils.GetEnvWithDefault(gin.EnvGinMode, gin.ReleaseMode))
	engine := gin.Default()
	server := newApiServer(entClient)
	newApiHandler(server, engine)
	// swagger, err := newSwaggerServer()
	return server, engine, nil
}

func newApiServer(db *ent.Client) *Server {
	secret, err := getSecret()
	utils.PanicIfError(err)
	return &Server{
		db:               db,
		baseUrl:          os.Getenv(api.BaseUrlName),
		secret:           secret,
		hintSize:         getHintSize(5),
		publicOperations: getPublicOperations(),
	}
}

func newApiHandler(server *Server, engine *gin.Engine) ServerInterface {
	handler := NewStrictHandler(
		server, []StrictMiddlewareFunc{server.authMiddleware()},
	)
	RegisterHandlers(engine, handler)
	// RegisterHandlersWithOptions(
	//     engine, handler, GinServerOptions{
	//         Middlewares: []MiddlewareFunc{server.authMiddleware()},
	//         // ErrorHandler: func(ctx *gin.Context, err error, code int) {
	//         // 	// This doesn't work since the error is generated by fmt.Errorf().
	//         // 	// Such error cannot be converted to err.ValidationError.
	//         // 	if ent.IsValidationError(err) {
	//         // 		code = http.StatusUnprocessableEntity
	//         // 	}
	//         // 	ctx.JSON(code, gin.H{"error": err.Error()})
	//         // },
	//     },
	// )
	return handler
}

//goland:noinspection GoUnusedFunction
func newSwaggerServer() (*openapi3.T, error) {
	swagger, err := GetSwagger()
	if err != nil {
		return nil, err
	}
	swagger.Servers = nil
	// swagger.AddServer(
	//     &openapi3.Server{
	//         URL:         server.baseUrl,
	//         Description: "Hybrid RBAC and ABAC auth service",
	//     },
	// )
	// swagger.Security = *openapi3.NewSecurityRequirements()
	return swagger, nil
}

func getHintSize(defaultValue int64) int {
	hintSize, err := strconv.ParseInt(
		utils.GetEnvWithDefaultNE(api.HintSizeName, "5"), 10, 32,
	)
	utils.PanicIfError(err)
	if hintSize < 1 {
		hintSize = defaultValue
	}
	return int(hintSize)
}

func getPublicOperations() []string {
	ops := slices.DeleteFunc(
		strings.Split(os.Getenv(api.PublicOpsName), ","),
		func(s string) bool { return "" == s },
	)
	if !slices.Contains(ops, "login") {
		ops = append(ops, "login")
	}
	if !slices.Contains(ops, "refreshAccessToken") {
		ops = append(ops, "refreshAccessToken")
	}
	// convert ops to CamelCase
	for i, op := range ops {
		ops[i] = strings.ToUpper(op[:1]) + op[1:]
	}
	return ops
}

func getSecret() ([]byte, error) {
	secret := os.Getenv(api.PrivateKeyName)
	if "" == secret {
		return nil, fmt.Errorf(
			"%s environment variable is not set", api.PrivateKeyName,
		)
	}
	key, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		return nil, err
	}
	return key, nil
}

// Domain returns the domain name of base URL.
func (s Server) Domain() string {
	u, err := url.Parse(s.baseUrl)
	if err != nil {
		return ""
	}
	return u.Hostname()
}

// getSecret returns the secret key for the JWT token generation.
// For use by `jwt.Parse()`.
func (s Server) getSecret(_ *jwt.Token) (interface{}, error) {
	return s.secret, nil
}

func (s Server) setCookie(
	gc *gin.Context, name, value, path string, maxAge int,
) {
	gc.SetCookie(name, value, maxAge, path, s.Domain(), true, true)
}

func (s Server) setToken(gc *gin.Context, accessToken, refreshToken string) {
	gc.SetSameSite(http.SameSiteStrictMode)
	s.setCookie(gc, accessTokenName, accessToken, "/", 3600)
	s.setCookie(
		gc, refreshTokenName, refreshToken, api.RefreshTokenPath, 7*24*3600,
	)
}

var _ StrictServerInterface = (*Server)(nil)
